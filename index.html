<!DOCTYPE html>
<html>
<head>
    <title>Python Code</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: monospace; white-space: pre; }
    </style>
</head>
<body>
<pre># -*- coding: utf-8 -*-
"""final_tutorial_wright.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J3NfQYc5DzbZRXhy9pdgLEl1qQ73mcSP

hyperlink to your webpage at github.io https://stellacwxxvi.github.io/

# The Overlooked Statistic: Underdiagnosis Among Minorities
**Stella Wright**  
Final Tutorial – Spring 2025  
Data Science Capstone Project

##Introduction

###Personal Motivation and Background


At the core of this project is a deeply personal motivation. Having been both mentored by and taught individuals with learning disabilities, I have long been interested in how these conditions are recognized and diagnosed. Most of my schooling occurred in predominantly white institutions, where the majority of diagnosed individuals I encountered were white, male, and from middle- to upper-income families. While this observation stems from personal experience, it sparked a broader curiosity I now wish to explore through data science.

For this project, I will analyze public health data related to the diagnosis of learning disabilities in young females. My goal is to investigate whether there are significant differences in diagnosis rates between males and females while examining the influence of socioeconomic status and poverty levels. By connecting my passion for data science with a topic related to my identity and lived experience, I hope to contribute meaningful insights to a conversation often limited by biased systems and unequal representation. This data is fascinating, personally relevant, and necessary to study if we aim to understand—and ultimately address—the disparities in educational and medical diagnoses.

###Purpose and Scope of Study

I have chosen to utilize the dataset from the Centers for Disease Control and Prevention (CDC) / National Center for Health Statistics, specifically the National Health Interview Survey covering the years 2019–2023. This dataset is available on the CDC’s official website and serves as a public resource intended to support CDC staff, public health departments, researchers, and other stakeholders. The CDC aims for these datasets to aid in "public health research, decision-making, priority setting, program evaluation, and resource allocation."

The National Health Interview Survey (NHIS) is conducted annually and gathers health-related data from U.S. households through voluntary participation. While the data is nationally representative, it is not exhaustive since it relies on individuals opting into the survey. Responses are categorized across various demographic variables, enabling researchers to analyze the data by race, sex, and poverty level, among other factors. For this project, I downloaded subsets of data that report positive diagnoses of Attention Deficit Hyperactivity Disorder (ADHD) and learning disabilities, specifically organized by sex, race, and poverty level.

Key survey questions included: “Has a doctor or other health professional ever told you that [child's name] had attention deficit hyperactivity disorder (ADHD) or attention deficit disorder (ADD)?” and “Has a representative from a school or a health professional ever told you that [child's name] had a learning disability?”

The data reflects the percentage of "Yes" responses out of all possible answers, which include “Yes,” “No,” “Refused,” and “Don’t know.” For this project, I downloaded the data in six parts: ADHD diagnoses segmented by sex, race, and poverty level, as well as learning disability diagnoses organized in the same manner.

There are several limitations to this dataset. First, the survey is voluntary, which may result in underrepresentation of individuals with ADHD or learning disabilities. Additionally, because the survey relies on self-reporting or parental reporting, there may be discrepancies in how learning disabilities are defined or understood. Some respondents may conflating ADHD with learning disabilities, potentially skewing the data. Furthermore, this dataset focuses on children and does not include information on adults with ADHD or learning disabilities, as those questions were not asked in the survey.

Despite these limitations, this dataset offers a robust sample size and provides valuable insights for analyzing disparities in diagnosis across different populations. The official documentation for the National Health Interview Survey dataset can be accessed here:https://www.cdc.gov/nchs/nhis/about/index.html#cdc_survey_profile_collected-whats-collected.

More detailed information about the survey structure and questionnaire content can be found in this NHIS Sample Child Questionnaire PDF: https://www.cdc.gov/nchs/data/nhis/Sample-Child-Questionnaire.pdf.

####Question
This study aims to determine whether positive diagnosis rates for ADHD and learning disabilities are influenced by race, gender, and socioeconomic status.

####Hypothesis
I hypothesize that young white males from higher-income brackets will have a higher prevalence of positive diagnoses compared to their counterparts. This may be due to several factors. Individuals from wealthier backgrounds often have greater access to healthcare resources and testing. Additionally, socialization patterns may play a role. Girls are typically socilized to be more compliant and may hide their struggles more effectively, while boys are often discouraged from showing vulnerability, which can result in more noticeable behavior. Lastly, racial and gender biases may influence who is referred for evaluation and diagnosis.

##Data: Extraction, Transform, and Load
This dataset was extracted from the CDC's official GitHub repository, which provides access to publicly available data from the National Health Interview Survey conducted between 2019 and 2023. After reviewing the associated use policies, users can download data files that are relevant to their research interests. The platform allows for a custom selection of variables, including demographic filters such as race, sex, age, and poverty level. For this project, I selected and downloaded specific subsets of data related to ADHD and learning disabilities.

####Load
For this project, I unitlized Python 3, pandas, maplotlib, and more. Our first code cell will be importing the necessary libraries.
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content
!git clone https://github.com/HHS-NHIS/SHS_TABLES_CHILDREN.git

# %cd /content/SHS_TABLES_CHILDREN/www

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.formula.api as smf

"""To load the data, I used the git clone command to download the repository and then utilized the pandas read_json(). The headers of each table, shown below, are presented without any transformation or cleaning."""

file_path = "EVER_ADHD__ind__poverty__.json"

with open(file_path, "r") as f:
    json_data = json.load(f)

# Extract column names and data
columns = json_data["classes"]  # Column names
data = json_data["data"]  # Actual data

# Create DataFrame
ADHD_pov_df = pd.DataFrame(data, columns=columns)

# Display DataFrame
from IPython.display import display
display(ADHD_pov_df)

"""Now, I will drop unneeded columns."""

ADHD_pov_df = ADHD_pov_df.drop(columns=["row_var", "rowLevels", "rowLevNum",	"selected",	"stat_group",	"col_group", "new_caption",	"new_caption2", "subLevels"], errors='ignore')

display(ADHD_pov_df)

"""####Rename Columns

To fully understand the data in this section, a couple of definitions need to be established.

**FPL**: Federal Poverty Level

**Lower Income**: Less than 100% of the FPL

**Moderate Income**: 100% to less than 200% of the FPL

**Higher Income**: 200% and more significant than the FPL

For each income level, there are two sections: one detailing the prevalence of positive diagnoses (responses of "yes" to the relevant question) and the other providing the confidence interval for the given prevalence. A confidence interval (CI) is a range of values used to estimate the actual value.

For example, the estimated prevalence of positive diagnoses in the Low-Income group for 2019 is 10.9%. However, the true prevalence could lie between 8.8% and 13.3%.
"""

ADHD_pov_df = ADHD_pov_df.rename(columns={
    "Less than 100% FPL__povertyA__EVER_ADHD__coef": "Low Income Group Prevalence",
    "Less than 100% FPL__povertyA__EVER_ADHD__se": "Low Income Group CI",
    "100% to less than 200% FPL__povertyB__EVER_ADHD__coef": "Moderate Income Group Prevalence",
    "100% to less than 200% FPL__povertyB__EVER_ADHD__se": "Moderate Income Group CI",
    "200% and greater FPL__povertyC__EVER_ADHD__coef": "Higher Income Group Prevalence",
    "200% and greater FPL__povertyC__EVER_ADHD__se": "Higher Income Group CI"
})

display(ADHD_pov_df)

"""Check dtypes"""

print(ADHD_pov_df.dtypes)

"""Checking the dtypes, we find that some columns are not properly formatted. While Confidence Intergale ranges and the Year are fine to stay as object, we must change the Prevalence rate to a numeric dtype."""

columns_to_convert = [
    "Low Income Group Prevalence",
    "Moderate Income Group Prevalence",
    "Higher Income Group Prevalence"
]

ADHD_pov_df[columns_to_convert] = ADHD_pov_df[columns_to_convert].apply(pd.to_numeric, errors='coerce')

print(ADHD_pov_df.dtypes)

"""Final Display of ADHD poverty levals"""

display(ADHD_pov_df)

"""**Figure 1** – Prevalence of ADHD by Income Group Over Times

Now, we will do a simular data cleaning process for poverty levals in the CDC's Learning Disability Section of the NHIS. Initial display of table:
"""

file_path = "EVER_LEARND__ind__poverty__.json"

with open(file_path, "r") as f:
    json_data = json.load(f)

# Extract column names and data
columns = json_data["classes"]  # Column names
data = json_data["data"]  # Actual data

# Create DataFrame
LD_pov_df = pd.DataFrame(data, columns=columns)

# Display DataFrame
from IPython.display import display
display(LD_pov_df)

"""Combined Cleaning process:"""

LD_pov_df = LD_pov_df.drop(
    columns=["row_var", "rowLevels", "rowLevNum", "selected", "stat_group", "col_group", "new_caption", "new_caption2", "subLevels"],
    errors='ignore'
)

LD_pov_df = LD_pov_df.rename(columns={
    "Less than 100% FPL__povertyA__EVER_LEARND__coef": "Low Income Group Prevalence",
    "Less than 100% FPL__povertyA__EVER_LEARND__se": "Low Income Group CI",
    "100% to less than 200% FPL__povertyB__EVER_LEARND__coef": "Moderate Income Group Prevalence",
    "100% to less than 200% FPL__povertyB__EVER_LEARND__se": "Moderate Income Group CI",
    "200% and greater FPL__povertyC__EVER_LEARND__coef": "Higher Income Group Prevalence",
    "200% and greater FPL__povertyC__EVER_LEARND__se": "Higher Income Group CI"
})

display(LD_pov_df)

"""Once again, we check the dtypes."""

print(LD_pov_df.dtypes)

"""change as specificed in the ADHD poverty leval table"""

columns_to_convert = [
    "Low Income Group Prevalence",
    "Moderate Income Group Prevalence",
    "Higher Income Group Prevalence"
]

LD_pov_df[columns_to_convert] = LD_pov_df[columns_to_convert].apply(pd.to_numeric, errors='coerce')

print(LD_pov_df.dtypes)

"""Final Display of Learning Disabilities Poverty Level Table"""

display(LD_pov_df)

"""**Figure 2** – Prevalence of Learning Disabilities Over Time by Income Group

Now we will explore ADHD across different racial groups. The options provided by the survey were: American Indian or Alaska Native only, Asian only, Black only, Native Hawaiian or Other Pacific Islander only, White only, American Indian and Alaska Native and White, Black and White.
"""

file_path = "EVER_ADHD__ind__race__.json"

with open(file_path, "r") as f:
    json_data = json.load(f)

# Extract column names and data
columns = json_data["classes"]  # Column names
data = json_data["data"]  # Actual data

# Create DataFrame
ADHD_race_df = pd.DataFrame(data, columns=columns)

# Display DataFrame
from IPython.display import display
display(ADHD_race_df)

"""Again, we will drop unneeded columns and rename columns as needed."""

ADHD_race_df = ADHD_race_df.drop(columns=[
    'row_var', 'rowLevels', 'rowLevNum', 'selected',
    'stat_group', 'col_group', 'new_caption', 'new_caption2', 'subLevels'
], errors='ignore')

ADHD_race_df = ADHD_race_df.rename(columns={
    "American Indian or Alaska Native only__raceA__EVER_ADHD__coef": "American Indian or Alaska Native only Prevalence",
    "American Indian or Alaska Native only__raceA__EVER_ADHD__se": "American Indian or Alaska Native only CI",

    "Asian only__raceB__EVER_ADHD__coef": "Asian only Prevalence",
    "Asian only__raceB__EVER_ADHD__se": "Asian only CI",

    "Black only__raceC__EVER_ADHD__coef": "Black only Prevalence",
    "Black only__raceC__EVER_ADHD__se": "Black only CI",

    "Native Hawaiian or Other Pacific Islander only__raceD__EVER_ADHD__coef": "Native Hawaiian or Other Pacific Islander only Prevalence",
    "Native Hawaiian or Other Pacific Islander only__raceD__EVER_ADHD__se": "Native Hawaiian or Other Pacific Islander only CI",

    "White only__raceE__EVER_ADHD__coef": "White only Prevalence",
    "White only__raceE__EVER_ADHD__se": "White only CI",

    "American Indian and Alaska Native and White__raceF__EVER_ADHD__coef": "American Indian and Alaska Native and White Prevalence",
    "American Indian and Alaska Native and White__raceF__EVER_ADHD__se": "American Indian and Alaska Native and White CI",

    "Black and White__raceG__EVER_ADHD__coef": "Black and White Prevalence",
    "Black and White__raceG__EVER_ADHD__se": "Black and White CI"
})



display(ADHD_race_df)

"""We can see that some data points are marked with an "*", which indicates that the estimate does not meet NCHS standards of reliability and was therefore not shown. I will remove these and replace them with NaN placeholders."""

ADHD_race_df.replace(["*", "*,*"], np.nan, inplace=True)
ADHD_race_df = ADHD_race_df.infer_objects(copy=False)

display(ADHD_race_df)

"""Check data types and change to previously :"""

print(ADHD_race_df.dtypes)

columns_to_float = [
    "American Indian or Alaska Native only Prevalence",
    "Asian only Prevalence",
    "Black only Prevalence",
    "Native Hawaiian or Other Pacific Islander only Prevalence",
    "White only Prevalence",
    "American Indian and Alaska Native and White Prevalence",
    "Black and White Prevalence"
]

# Convert Prevalence columns to float
ADHD_race_df[columns_to_float] = ADHD_race_df[columns_to_float].apply(pd.to_numeric, errors='coerce')

columns_to_object = [
    "American Indian or Alaska Native only CI",
    "Asian only CI",
    "Black only CI",
    "Native Hawaiian or Other Pacific Islander only CI",
    "White only CI",
    "American Indian and Alaska Native and White CI",
    "Black and White CI"
]

# Convert CI columns to object
ADHD_race_df[columns_to_object] = ADHD_race_df[columns_to_object].astype("object")

# Check types
print(ADHD_race_df.dtypes)

"""Final Display of ADHD Race Table"""

display(ADHD_race_df)

"""**Figure 3** – Prevalence of ADHD Over Time by Race

We will use a similar process for The Learning Disability Race Table
"""

file_path = "EVER_LEARND__ind__race__.json"

with open(file_path, "r") as f:
    json_data = json.load(f)

# Extract column names and data
columns = json_data["classes"]  # Column names
data = json_data["data"]  # Actual data

# Create DataFrame
LD_race_df = pd.DataFrame(data, columns=columns)

# Display DataFrame
from IPython.display import display
display(LD_race_df)

"""Combine data cleaning of dropping columns, renaming columns, and replacing missing data with NaN place holders."""

LD_race_df = LD_race_df.drop(columns=[
    'row_var', 'rowLevels', 'rowLevNum', 'selected',
    'stat_group', 'col_group', 'new_caption', 'new_caption2', 'subLevels'
], errors='ignore')

LD_race_df = LD_race_df.rename(columns={
    "American Indian or Alaska Native only__raceA__EVER_LEARND__coef": "American Indian or Alaska Native only Prevalence",
    "American Indian or Alaska Native only__raceA__EVER_LEARND__se": "American Indian or Alaska Native only CI",

    "Asian only__raceB__EVER_LEARND__coef": "Asian only Prevalence",
    "Asian only__raceB__EVER_LEARND__se": "Asian only CI",

    "Black only__raceC__EVER_LEARND__coef": "Black only Prevalence",
    "Black only__raceC__EVER_LEARND__se": "Black only CI",

    "Native Hawaiian or Other Pacific Islander only__raceD__EVER_LEARND__coef": "Native Hawaiian or Other Pacific Islander only Prevalence",
    "Native Hawaiian or Other Pacific Islander only__raceD__EVER_LEARND__se": "Native Hawaiian or Other Pacific Islander only CI",

    "White only__raceE__EVER_LEARND__coef": "White only Prevalence",
    "White only__raceE__EVER_LEARND__se": "White only CI",

    "American Indian and Alaska Native and White__raceF__EVER_LEARND__coef": "American Indian and Alaska Native and White Prevalence",
    "American Indian and Alaska Native and White__raceF__EVER_LEARND__se": "American Indian and Alaska Native and White CI",

    "Black and White__raceG__EVER_LEARND__coef": "Black and White Prevalence",
    "Black and White__raceG__EVER_LEARND__se": "Black and White CI"
})

LD_race_df.replace(["*", "*,*"], np.nan, inplace=True)
LD_race_df = LD_race_df.infer_objects(copy=False)

display(LD_race_df)

"""Check Dtypes"""

print(LD_race_df.dtypes)

columns_to_float = [
    "American Indian or Alaska Native only Prevalence",
    "Asian only Prevalence",
    "Black only Prevalence",
    "Native Hawaiian or Other Pacific Islander only Prevalence",
    "White only Prevalence",
    "American Indian and Alaska Native and White Prevalence",
    "Black and White Prevalence"
]

# Convert Prevalence columns to float
LD_race_df[columns_to_float] = LD_race_df[columns_to_float].apply(pd.to_numeric, errors='coerce')

columns_to_object = [
    "American Indian or Alaska Native only CI",
    "Asian only CI",
    "Black only CI",
    "Native Hawaiian or Other Pacific Islander only CI",
    "White only CI",
    "American Indian and Alaska Native and White CI",
    "Black and White CI"
]

# Convert CI columns to object
LD_race_df[columns_to_object] = LD_race_df[columns_to_object].astype("object")

# Check types
print(LD_race_df.dtypes)

"""Final Display of Learning Disability Race Table"""

display(LD_race_df)

"""**Figure 4** – Prevalence of Learning Disabilites Over Time by Race

Our final two tables will explore difference in sex in positive cases of ADHD and learning disabilities.
"""

file_path = "EVER_ADHD__ind__sex__.json"

with open(file_path, "r") as f:
    json_data = json.load(f)

# Extract column names and data
columns = json_data["classes"]  # Column names
data = json_data["data"]  # Actual data

# Create DataFrame
ADHD_sex_df = pd.DataFrame(data, columns=columns)

# Display DataFrame
from IPython.display import display
display(ADHD_sex_df)

"""Drop Columns and Rename for Clarity"""

ADHD_sex_df = ADHD_sex_df.drop(columns=[
    'row_var', 'rowLevels', 'rowLevNum', 'selected',
    'stat_group', 'col_group', 'new_caption', 'new_caption2', 'subLevels'
], errors='ignore')

ADHD_sex_df = ADHD_sex_df.rename(columns={
    "Female__sexA__EVER_ADHD__coef": "Female Prevalence",
    "Female__sexA__EVER_ADHD__se": "Female CI",

    "Male__sexB__EVER_ADHD__coef": "Male Prevalence",
    "Male__sexB__EVER_ADHD__se": "Male CI"
})

display(ADHD_sex_df)

"""Check dtypes"""

print(ADHD_sex_df.dtypes)

"""Change Female and Male Prevalence to numeric dtypes"""

columns_to_float = [
    "Female Prevalence",
    "Male Prevalence"
]

# Convert Prevalence columns to float
ADHD_sex_df[columns_to_float] = ADHD_sex_df[columns_to_float].apply(pd.to_numeric, errors='coerce')

print(ADHD_sex_df.dtypes)

"""Final Display ADHD Sex Table"""

display(ADHD_sex_df)

"""**Figure 5** – Prevalence of ADHD Over Time by Sex

Finally, we will follow a similar process to generate a table showing the differences in learning disability diagnoses by sex.
"""

file_path = "EVER_LEARND__ind__sex__.json"

with open(file_path, "r") as f:
    json_data = json.load(f)

# Extract column names and data
columns = json_data["classes"]  # Column names
data = json_data["data"]  # Actual data

# Create DataFrame
LD_sex_df = pd.DataFrame(data, columns=columns)

# Display DataFrame
from IPython.display import display
display(LD_sex_df)

"""Drop columns and rename for clarity"""

LD_sex_df = LD_sex_df.drop(columns=[
    'row_var', 'rowLevels', 'rowLevNum', 'selected',
    'stat_group', 'col_group', 'new_caption', 'new_caption2', 'subLevels'
], errors='ignore')

LD_sex_df = LD_sex_df.rename(columns={
    "Female__sexA__EVER_LEARND__coef": "Female Prevalence",
    "Female__sexA__EVER_LEARND__se": "Female CI",

    "Male__sexB__EVER_LEARND__coef": "Male Prevalence",
    "Male__sexB__EVER_LEARND__se": "Male CI"
})

display(LD_sex_df)

"""check dtypes and change as needed"""

print(LD_sex_df.dtypes)

columns_to_float = [
    "Female Prevalence",
    "Male Prevalence"
]

# Convert Prevalence columns to float
LD_sex_df[columns_to_float] = LD_sex_df[columns_to_float].apply(pd.to_numeric, errors='coerce')

print(LD_sex_df.dtypes)

"""Final Display of Learning Disabilty Sex Table"""

display(LD_sex_df)

"""**Figure 6** – Prevalence of Learning Disabilties Over Time by Sex

##Exploratory Data Analysis (EDA)
###Prevalance Rates per Poverty Group
In this exploration, I examined how the prevalence of ADHD (Attention Deficit Hyperactivity Disorder) and Learning Disabilities (LD) has changed over time across different income groups.

To accomplish this, I first merged the two separate poverty datasets—one for ADHD and another for LD—using the `'Year'` column with `pd.merge()`. I use suffixes (`_ADHD` and `_LD`) to distinguish the columns after the merge.

With the data combined, I plotted six lines to visualize the yearly trends in prevalence. Each condition (ADHD and LD) was analyzed by income group (Low, Moderate, and High), providing a detailed view of how socioeconomic factors may influence diagnosis rates over time. The x-axis represents the year, while the y-axis shows the prevalence. This line graph helped reveal whether specific income groups experienced sharper increases or declines in reported prevalence rates.

To complement the time-series analysis, I calculated the mean prevalence rate for each income group over the entire period covered by the data. These mean values were then used to create a summarized data frame displaying the average prevalence of ADHD and LD by income level.

Finally, I created a bar chart using this new summary data frame to visually compare average prevalence rates across income groups. Each group (Low, Moderate, High) has two bars—one for ADHD and one for LD—facilitating easy comparison. This second visualization provided a more aggregated view, reinforcing or contrasting any trends observed in the line graph.
"""

# Combine ADHD and LD poverty data
combined_pov_df = pd.merge(ADHD_pov_df, LD_pov_df, on='Year', suffixes=('_ADHD', '_LD'))

# Line graph: Prevalence over time by income group
plt.figure(figsize=(12, 6))
plt.plot(combined_pov_df['Year'], combined_pov_df['Low Income Group Prevalence_ADHD'], label='ADHD - Low Income')
plt.plot(combined_pov_df['Year'], combined_pov_df['Moderate Income Group Prevalence_ADHD'], label='ADHD - Moderate Income')
plt.plot(combined_pov_df['Year'], combined_pov_df['Higher Income Group Prevalence_ADHD'], label='ADHD - High Income')
plt.plot(combined_pov_df['Year'], combined_pov_df['Low Income Group Prevalence_LD'], label='LD - Low Income')
plt.plot(combined_pov_df['Year'], combined_pov_df['Moderate Income Group Prevalence_LD'], label='LD - Moderate Income')
plt.plot(combined_pov_df['Year'], combined_pov_df['Higher Income Group Prevalence_LD'], label='LD - High Income')
plt.xlabel('Year')
plt.ylabel('Prevalence Rate (%)')
plt.title('Prevalence of ADHD and Learning Disabilities Over Time by Income Group')
plt.legend()
plt.grid(True)
plt.show()

"""**Figure 7** – Line Graph: Prevalence of ADHD and Learning Disabilities Over Time by Income Group"""

# Merge the ADHD and LD dataframes on 'Year'
combined_pov_df = pd.merge(ADHD_pov_df, LD_pov_df, on='Year', suffixes=('_ADHD', '_LD'))

# Calculate mean prevalence for each income group
adhd_means = [
    combined_pov_df['Low Income Group Prevalence_ADHD'].mean(),
    combined_pov_df['Moderate Income Group Prevalence_ADHD'].mean(),
    combined_pov_df['Higher Income Group Prevalence_ADHD'].mean()
]

ld_means = [
    combined_pov_df['Low Income Group Prevalence_LD'].mean(),
    combined_pov_df['Moderate Income Group Prevalence_LD'].mean(),
    combined_pov_df['Higher Income Group Prevalence_LD'].mean()
]

# Create a new DataFrame for the bar plot
mean_prevalence = pd.DataFrame({
    'Income Group': ['Low', 'Moderate', 'High'],
    'ADHD Prevalence': adhd_means,
    'LD Prevalence': ld_means
})

# Plotting the bar graph
plt.figure(figsize=(8, 6))
bar_width = 0.35
index = np.arange(len(mean_prevalence['Income Group']))

plt.bar(index, mean_prevalence['ADHD Prevalence'], bar_width, label='ADHD')
plt.bar(index + bar_width, mean_prevalence['LD Prevalence'], bar_width, label='Learning Disabilities')

plt.xlabel('Income Group')
plt.ylabel('Mean Prevalence Rate (%)')
plt.title('Mean Prevalence of ADHD and Learning Disabilities by Income Group')
plt.xticks(index + bar_width / 2, mean_prevalence['Income Group'])
plt.legend()
plt.grid(axis='y')
plt.tight_layout()
plt.show()

"""**Figure 8** – Bar Chart: Mean Prevalence of ADHD and Learning Disabilities by Income Group

**Analysis**

The data presented in this graph contradicts my initial hypothesis that individuals from higher tax brackets would have higher rates of diagnoses. My graph illustrates changes in ADHD and learning disabilities from 2019 to 2023 across different income groups. Throughout these five years, children from low-income families consistently show the highest rates of both conditions.

ADHD prevalence peaked among low-income families in 2020, likely due to the stress and disruptions caused by the COVID-19 pandemic, before experiencing a slight decline. In contrast, moderate- and high-income groups show a steady increase in prevalence over time, particularly for learning disabilities in high-income families. This trend may be attributed to greater awareness and better access to diagnostic services in these communities.

Overall, while ADHD rates tend to fluctuate, learning disabilities display a more consistent upward trend.

###Prevalance Rates per Racial Idenity

To explore how the prevalence of ADHD and Learning Disabilities (LD) varied over time by race, I began by generating two line graphs. These graphs visualized the prevalence rates for each racial group across the years available in the dataset.

For ADHD and LD, I looped through the columns in their respective data frames, selecting only those columns that included "Prevalence" in their names. I plotted these rates against the "Year" column, adding appropriate labels, titles, and a grid to enhance readability.

After visualizing the trends over time, I shifted my focus to the overall mean prevalence by race. I filtered the columns again to isolate only the prevalence rates and computed the mean for each racial group across all years.

To improve the plot's clarity, I removed the " Prevalence" suffix from each column name, retaining only the race labels. Finally, I combined the ADHD and LD averages into a single data frame and displayed them side by side in a grouped bar chart, making it easier to compare the average prevalence rates of ADHD and LD across different racial groups.
"""

# Line graph: Prevalence over time by race for ADHD
plt.figure(figsize=(12, 6))
for col in ADHD_race_df.columns:
    if 'Prevalence' in col:
        plt.plot(ADHD_race_df['Year'], ADHD_race_df[col], label=col)
plt.xlabel('Year')
plt.ylabel('Prevalence Rate (%)')
plt.title('Prevalence of ADHD Over Time by Race')
plt.legend()
plt.grid(True)
plt.show()

# Line graph: Prevalence over time by race for LD
plt.figure(figsize=(12, 6))
for col in LD_race_df.columns:
    if 'Prevalence' in col:
        plt.plot(LD_race_df['Year'], LD_race_df[col], label=col)
plt.xlabel('Year')
plt.ylabel('Prevalence Rate (%)')
plt.title('Prevalence of Learning Disabilities Over Time by Race')
plt.legend()
plt.grid(True)
plt.show()

"""**Figure 9** – Line graphs: Prevalence of ADHD and Learning Disabilities Over Time by Race"""

# Calculate means
adhd_means = ADHD_race_df[[col for col in ADHD_race_df.columns if 'Prevalence' in col]].mean()
ld_means = LD_race_df[[col for col in LD_race_df.columns if 'Prevalence' in col]].mean()

# Clean up column names to just race
adhd_means.index = [col.replace(' Prevalence', '') for col in adhd_means.index]
ld_means.index = [col.replace(' Prevalence', '') for col in ld_means.index]

# Combine into a DataFrame
mean_df = pd.DataFrame({'ADHD': adhd_means, 'LD': ld_means})

# Plot
mean_df.plot(kind='bar', figsize=(12, 6))
plt.xlabel('Race')
plt.ylabel('Mean Prevalence Rate (%)')
plt.title('Mean Prevalence of ADHD and Learning Disabilities by Race')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Condition')
plt.tight_layout()
plt.show()

"""**Figure 10** – Bar Chart:
Mean Prevalence of ADHD and Learning Disabilities by Race

**Analysis**

The first graph illustrates the prevalence of ADHD over time, broken down by race. A notable trend is the sharp increase in ADHD diagnoses among individuals identifying as "Black and White," particularly between 2021 and 2023. Similarly, those categorized as "White only" show a steady upward trend. In contrast, the "Black only" group maintains relatively stable rates with only minor fluctuations. The "Asian only" group consistently demonstrates the lowest prevalence, although there is a gradual increase over time. These variations may reflect disparities in access to diagnoses or differing cultural perceptions and stigmas related to mental health.

The second graph presents the prevalence of learning disabilities (LD) over the same time frame and racial categories. Once again, individuals identifying as "Black and White" exhibit the highest and most consistent rates, with a slow but steady increase. The "Black only" and "White only" groups follow similar trends, while the "Asian only" group maintains the lowest prevalence. This pattern closely mirrors the trends seen in ADHD, suggesting that similar factors—such as socioeconomic conditions or inequities in access to special education services—may influence both diagnoses.

The third graph compares the mean prevalence of ADHD and learning disabilities by race. It indicates that the "Black and White" group has the highest mean rates for both conditions, followed by the "White only" and "Black only" groups. The "Asian only" population shows the lowest average prevalence across both categories. This visualization highlights racial disparities in the diagnosis and reporting of ADHD and LD, potentially shaped by a complex interplay of social, cultural, and systemic healthcare factors. Overall, these findings support my initial hypothesis that White children would exhibit the highest diagnosis rates; however, the "Black and White" group surpasses them, indicating a more nuanced reality.

###Prevalance Rates per Sex
Below is an exploratory analysis of the prevalence of learning disabilities (LD) and ADHD by sex over time.

First, I visualized the trends in LD prevalence over time using a line graph. I plotted each sex on the same graph to compare their trajectories from year to year. This helped visually identify differences or patterns in prevalence by sex over time.

Next, I shifted the focus to summarizing the data using a bar graph that compares the mean prevalence of LD and ADHD between males and females. To do this, I first created a new data frame where I calculated the average prevalence rates separately for LD and ADHD by sex. This involved taking the mean of the respective prevalence columns from the original datasets.

For the bar plot, I set the x-axis to represent sex and plotted two side-by-side bars for each group—one for LD and one for ADHD—using a defined bar width. This format made it easier to compare the mean prevalence of each condition across sexes. I used tight_layout() to ensure the formatting was clean and nothing overlapped.

This approach allowed me to examine the temporal trends and overall average differences in prevalence rates, offering a complete understanding of how these conditions differ by sex.
"""

# Line graph: Prevalence over time by sex for LD
plt.figure(figsize=(12, 6))
plt.plot(LD_sex_df['Year'], LD_sex_df['Female Prevalence'], label='Female')
plt.plot(LD_sex_df['Year'], LD_sex_df['Male Prevalence'], label='Male')
plt.xlabel('Year')
plt.ylabel('Prevalence Rate (%)')
plt.title('Prevalence of Learning Disabilities Over Time by Sex')
plt.legend()
plt.grid(True)
plt.show()

"""**Figure 11** – Line graph: Prevalence of ADHD and Learning Disabilities Over time by Sex"""

# Bar graph: Mean prevalence by sex for LD and ADHD

# Create DataFrame for mean prevalence
mean_prevalence_df = pd.DataFrame({
    'Sex': ['Female', 'Male'],
    'LD': [
        LD_sex_df['Female Prevalence'].mean(),
        LD_sex_df['Male Prevalence'].mean()
    ],
    'ADHD': [
        ADHD_sex_df['Female Prevalence'].mean(),
        ADHD_sex_df['Male Prevalence'].mean()
    ]
})

# Plotting
x = np.arange(len(mean_prevalence_df['Sex']))  # label locations
width = 0.35  # width of the bars

plt.figure(figsize=(8, 6))
plt.bar(x - width/2, mean_prevalence_df['LD'], width, label='LD')
plt.bar(x + width/2, mean_prevalence_df['ADHD'], width, label='ADHD')

plt.xlabel('Sex')
plt.ylabel('Mean Prevalence Rate (%)')
plt.title('Mean Prevalence by Sex: Learning Disabilities vs. ADHD')
plt.xticks(x, mean_prevalence_df['Sex'])
plt.legend()
plt.grid(axis='y')
plt.tight_layout()
plt.show()

"""**Figure 12** – Bar chat: Mean Prevalence of ADHD and Learning Disabilities by Sex

**Analysis**

My original hypothesis that men have higher diagnosis rates than women has been strongly validated.

My first graph illustrates the prevalence of learning disabilities from 2019 to 2023, separated by sex. It's noteworthy that, throughout these years, males consistently show a higher prevalence rate than females. There is a significant spike in 2020 for both sexes, with a sharper increase for females, although the rate for males remains higher. By 2023, the prevalence for males will continue to rise, while the female rate will fluctuate but ultimately end up lower than its peak in 2020.

My second graph presents the mean prevalence of learning disabilities (LD) and ADHD among males and females. It indicates that males have significantly higher rates of both LD and ADHD compared to females. The rates of ADHD, in particular, are nearly double for males compared to females.

##Linear Regression: Evaluation of Socioeconomic Status

For my first research question, I aimed to investigate whether a child's socioeconomic status (SES), measured explicitly by poverty level, influences the likelihood of being diagnosed with ADHD or a learning disability, using data from the CDC's National Health Interview Survey (NHIS).

I focused on two main factors: the poverty level category (low, moderate, or high income) and the survey year. My dependent variable was the prevalence of diagnoses for ADHD or learning disabilities. To analyze this, I employed a linear regression model to determine if there is a pattern or relationship over time. Including the year in my analysis helps to account for broader changes that could influence diagnosis rates, such as shifts in policy, awareness, or diagnostic criteria.

The objective of this model is to better understand whether children from lower-income backgrounds are more likely to receive these diagnoses and to see if this relationship has changed or remained consistent over time.

**Preparing Data for Regression**

My next step involved reshaping the poverty-related dataset to prepare it for analysis and visualization. The original data frame was in a wide format, with each column representing a specific combination of income group, measure type (Prevalence or Confidence Interval), and condition (ADHD or Learning Disability).

I utilized the melt function to transform this wide data frame into a long format, using "Year" as the identifier and consolidating the remaining columns into a single variable column. Next, I applied a regular expression with str.extract to separate the combined column into three meaningful components: "Income Group," "Measure," and "Condition." After removing the now-unnecessary combined variable column, I pivoted the DataFrame to ensure each row represented a unique combination of year, income group, and condition, with separate columns for each measure type. This tidy format facilitates more straightforward plotting and comparison of prevalence and confidence intervals across different groups over time.
"""

# Melt the wide DataFrame into long format
df_long = combined_pov_df.melt(
    id_vars='Year',
    var_name='Group_Variable',
    value_name='Value'
)

# Extract 'Income Group', 'Measure' (Prevalence/CI), and 'Condition' (ADHD/LD)
df_long[['Income Group', 'Measure', 'Condition']] = df_long['Group_Variable'].str.extract(
    r'(.+?) Income Group (Prevalence|CI)_(ADHD|LD)'
)

# Drop the old combined variable column
df_long = df_long.drop(columns='Group_Variable')

# Pivot without aggregation (to avoid mean error)
df_pov_tidy = df_long.pivot(
    index=['Year', 'Income Group', 'Condition'],
    columns='Measure',
    values='Value'
).reset_index()

display(df_pov_tidy)

"""To prepare the data for numerical analysis and ensure data type consistency, I converted key columns in the `df_pov_tidy` DataFrame to numeric format. Specifically, I applied `pd.to_numeric` to the "Year," "CI" (Confidence Interval), and "Prevalence" columns, using the parameter `errors='coerce'` to handle any invalid entries gracefully by converting them to NaN values. Next, I converted the "Income Group" column into a categorical data type to simplify the encoding and plotting of categorical income levels. I created a corresponding "Income Code" numeric using `.cat.codes`. This process ensures that the data is clean and ready for subsequent statistical analysis or visualizations."""

# Check dtypes of df_pov_tidy
df_pov_tidy.dtypes

df_pov_tidy['Year'] = pd.to_numeric(df_pov_tidy['Year'], errors='coerce')
df_pov_tidy['CI'] = pd.to_numeric(df_pov_tidy['CI'], errors='coerce')
df_pov_tidy['Prevalence'] = pd.to_numeric(df_pov_tidy['Prevalence'], errors='coerce')

df_pov_tidy['Income Code'] = df_pov_tidy['Income Group'].astype('category').cat.codes

df_pov_tidy.dtypes

"""I developed a custom function to conduct and visualize linear regression analyses to explore the relationship between poverty-related variables and prevalence rates. This function, `regress_with_stats,` utilizes the `scipy.stats.linregress` method. It takes a data frame and a list of independent variables, generating scatter plots with fitted regression lines for each variable.

For each independent variable in the list, I plotted "Prevalence" against that variable, overlaying a red trend line based on the regression results. Additionally, I directly included key statistics—such as the p-value, r-value, standard error, slope, and intercept—in each plot title to summarize the strength and reliability of the observed relationships.

To accommodate regression on categorical data, such as "Income Group," I first encoded this variable numerically into a new column called "Income Level." This approach facilitates a quick visual and statistical assessment of linear trends between prevalence and explanatory variables like year or income level.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def regress_with_stats(df, observations):
    fig, ax = plt.subplots(1, len(observations), figsize=(5 * len(observations), 5), sharex=False)

    if len(observations) == 1:
        ax = [ax]  # Make ax indexable if only one plot

    for i, o in enumerate(observations):
        x = df[o]
        y = df['Prevalence']

        slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
        diag_str = f"p-value={p_value:.1g}\nr-value={r_value:.3f}\nstd err.={std_err:.3f}\nslope={slope:.3f}\nintercept={intercept:.3f}"

        df.plot.scatter(x=o, y='Prevalence', title=diag_str, ax=ax[i])
        pts = np.linspace(x.min(), x.max(), 500)
        ax[i].plot(pts, slope * pts + intercept, lw=1, color='red')

# Example usage:
# If 'Income Group' is categorical, convert it to numeric before passing
df_pov_tidy['Income Level'] = df_pov_tidy['Income Group'].astype('category').cat.codes
regress_with_stats(df_pov_tidy, ['Year', 'Income Level'])

"""**Figure 13** - Linear Regression: An Examination of socioeconomic status (SES) on the prediction of the likelihood of a child being diagnosed with ADHD or a learning disability

**Analysis**

An analysis of the prevalence of learning disabilities and ADHD reveals several key trends when examined over time and across income levels:

The first plot illustrates the relationship between prevalence and year (2019–2023). The red trend line shows a slight increase in prevalence over time, with a slope of 0.405. However, the p-value of 0.2 indicates that this upward trend is not statistically significant, while the r-value of 0.237 suggests a weak positive correlation. This implies that although there may be a slight upward trend in prevalence in recent years, the data does not strongly support a consistent or reliable increase.

The second plot depicts the prevalence of income level, categorized into groups (e.g., 0 = low, 1 = medium, 2 = high). This plot indicates a more apparent upward trend in prevalence as income level increases, with a slope of 1.080. The p-value of 0.05 meets the standard for statistical significance, and the r-value of 0.364 indicates a moderate positive correlation. This suggests that individuals from higher income levels are more likely to report or be diagnosed with learning disabilities and ADHD, potentially reflecting differences in access to diagnostic resources, educational support systems, or awareness.

In summary, while the overall prevalence of learning disabilities and ADHD does not show a strong or consistent increase over time, income level appears to be a more significant factor. This may indicate socioeconomic disparities in diagnosis and identification.

##Dicision Tree Classification Model: Evaluation of Race and Gender
For my second research question, I aimed to explore whether race and gender influence the likelihood of being diagnosed with ADHD or a learning disability. Using the NHIS dataset, I specifically analyzed whether a child received a diagnosis (yes or no) and how their race and gender might predict this.

To conduct this analysis, I utilized a decision tree classification model. This approach is beneficial because it does not assume a linear relationship but can uncover more complex patterns and interactions between these demographic factors. The model is designed to highlight potential disparities in diagnosis rates and provide a clearer understanding of how race and gender may impact who receives these diagnoses.

**Preparing Data for Decision Tree Classification Model**

I began my analysis by converting two wide-format datasets—one for ADHD diagnoses and another for learning disabilities (LD)—into a consistent long format more suitable for time series and categorical analysis.

I utilized the `pd.wide_to_long()` function on both datasets to achieve this. Initially, these datasets contained multiple columns for each racial group and measure (e.g., "White only Prevalence" and "White only CI"), which is not ideal for tidy data analysis. To address this issue, I transformed the data into a long format where each row corresponds to a unique combination of year, racial group, and measure (such as prevalence or confidence interval). The steps I took included:

1. The columns should be renamed to replace spaces with underscores, allowing `wide_to_long()` to process the column names accurately.
2. Specifying the stub names (the racial categories), the index column (`Year`), and the part of the column name that distinguishes the measure type (either `Prevalence` or `CI`).

After reshaping the ADHD and LD datasets, I added a new `Condition` column to indicate whether each row pertains to ADHD or LD. Finally, I combined the two long-format datasets into one dataset, enabling a unified analysis of both conditions.

This transformation facilitates more straightforward plotting, grouping, and statistical comparisons across race, year, and condition.
"""

import pandas as pd

# Step 1: Melt the ADHD dataframe
adhd_long = pd.wide_to_long(
    ADHD_race_df.rename(columns=lambda x: x.replace(' ', '_')),
    stubnames=['American_Indian_or_Alaska_Native_only', 'Asian_only', 'Black_only',
               'Native_Hawaiian_or_Other_Pacific_Islander_only', 'White_only',
               'American_Indian_and_Alaska_Native_and_White', 'Black_and_White'],
    i='Year',
    j='Measure',
    sep='_',
    suffix='(Prevalence|CI)'
).reset_index()

# Step 2: Melt the LD dataframe similarly
ld_long = pd.wide_to_long(
    LD_race_df.rename(columns=lambda x: x.replace(' ', '_')),
    stubnames=['American_Indian_or_Alaska_Native_only', 'Asian_only', 'Black_only',
               'Native_Hawaiian_or_Other_Pacific_Islander_only', 'White_only',
               'American_Indian_and_Alaska_Native_and_White', 'Black_and_White'],
    i='Year',
    j='Measure',
    sep='_',
    suffix='(Prevalence|CI)'
).reset_index()

# Step 3: Add condition labels
adhd_long['Condition'] = 'ADHD'
ld_long['Condition'] = 'LD'

# Step 4: Combine both long dataframes
combined_race_long = pd.concat([adhd_long, ld_long], ignore_index=True)

display(combined_race_long)

"""To start preparing the dataset for modeling, I first examined the data types in the `combined_race_long` DataFrame to identify which columns needed conversion. I focused on a set of features representing different racial groups. These columns initially contained values formatted as strings, including symbols such as commas and percent signs (e.g., "12.5%", "1,000"), which are not suitable for numerical analysis.

To clean and convert these features, I iterated through each column in the `race_features` list and took the following steps:

1. Converted the values to strings to ensure compatibility with string operations.
2. Used `.str.replace()` with a regular expression to remove commas and percent signs.
3. Converted the cleaned strings to numeric values using `pd.to_numeric()`, coercing invalid entries into NaN.

After cleaning the data, I prepared it for modeling:

- `X` contains the cleaned numeric race-based features.
- `Y' is a categorical encoding of the `Condition` column, converted into numerical labels using `.astype('category').cat.codes`.

Finally, I rechecked the data types in `combined_race_long` to confirm the successful transformations.
"""

# Check dtypes of combined_race_long
combined_race_long.dtypes

# Convert race-based features to numeric
race_features = [
    'American_Indian_or_Alaska_Native_only',
    'Asian_only',
    'Black_only',
    'Native_Hawaiian_or_Other_Pacific_Islander_only',
    'White_only',
    'American_Indian_and_Alaska_Native_and_White',
    'Black_and_White'
]

# Strip commas, percent signs, etc. and convert to float
for col in race_features:
    df[col] = pd.to_numeric(df[col].astype(str).str.replace(r'[%,]', '', regex=True), errors='coerce')

X = df[race_features]
y = df['Condition'].astype('category').cat.codes

combined_race_long.dtypes

"""In this code section, I trained a Decision Tree classifier to predict a person's condition based on their reported racial identity using a preprocessed data frame called `combined_race_long.`

First, I selected a subset of race-related features (e.g., 'White_only,' 'Black_and_White,' etc.) as my predictors (X). I then set my target variable (y) to the categorical codes of the 'Condition' column, which I encoded using Pandas' `.astype('category').cat.codes`. I printed a dictionary of the mapping to keep track of how these codes map back to the original labels.

Next, I split the data into training and testing sets using `train_test_split,` with a test size of 20% and a fixed random state for reproducibility.

For modeling, I employed a `DecisionTreeClassifier` from sci-kit-learn, limiting the depth of the tree to 3 to prevent overfitting and maintain interpretability. After fitting the model to the training data, I made predictions on the test set.

To evaluate the model's performance, I printed its accuracy, precision, and recall using metrics from the sci-kit-learn library, applying weighted averages to account for class imbalances. I also visualized the confusion matrix using `ConfusionMatrixDisplay` better to understand the distribution of correct and incorrect predictions.

Finally, I analyzed the decision tree itself. I printed the feature importances to see which race categories contributed most to the classification. I used `plot_tree` to visually inspect the structure of the trained tree, labeling the nodes with feature names and class outputs for better interpretability.
"""

# Features and Target
features = [
    'American_Indian_or_Alaska_Native_only',
    'Asian_only',
    'Black_only',
    'Native_Hawaiian_or_Other_Pacific_Islander_only',
    'White_only',
    'American_Indian_and_Alaska_Native_and_White',
    'Black_and_White'
]
X = combined_race_long[features]
y = combined_race_long['Condition'].astype('category').cat.codes

# Check label mapping (optional)
label_mapping = dict(enumerate(combined_race_long['Condition'].astype('category').cat.categories))
print("Label Mapping:", label_mapping)

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Model training
mod_dt = DecisionTreeClassifier(max_depth=3, random_state=1)
mod_dt.fit(X_train, y_train)

# Predictions
predictions = mod_dt.predict(X_test)

# Evaluation
print(f"The accuracy of the Decision Tree is {metrics.accuracy_score(predictions, y_test):.3f}")
print(f"The Precision of the Decision Tree is {metrics.precision_score(predictions, y_test, average='weighted'):.3f}")
print(f"The Recall of the Decision Tree is {metrics.recall_score(predictions, y_test, average='weighted'):.3f}")

# Confusion Matrix
ConfusionMatrixDisplay.from_estimator(mod_dt, X_test, y_test, cmap=plt.cm.Blues)
plt.title("Confusion Matrix")
plt.show()

# Feature Importances
print("\nFeature Importances:")
for feature, importance in zip(features, mod_dt.feature_importances_):
    print(f"{feature}: {importance:.3f}")

# Plot Tree
plt.figure(figsize=(12, 8))
plot_tree(
    mod_dt,
    feature_names=features,
    class_names=mod_dt.classes_.astype(str),
    filled=True,
    fontsize=50  # Adjust this value to make text smaller or larger
)
plt.title("Decision Tree for ADHD vs. LD")
plt.show()

"""**Figure 14** - Dicision Tree Classification Model: An examination of the role of race in predicting disparities in diagnosis rates for ADHD and learning disabilities

I will now do a similar process for the Gender binary. To prepare for an analysis comparing the prevalence of learning disabilities (LD) and ADHD by sex, I first added a new column labeled "Condition" to each dataset to differentiate between the two when they were combined. I assigned the string "LD" to all rows in the LD_sex_df data frame and "ADHD" to the ADHD_sex_df data frame.

Next, I reordered the columns in both datasets to ensure consistency and facilitate analysis. The desired order was year, prevalence, and confidence intervals for both females and males, followed by the new "Condition" column. This step was crucial to aligning both data frames structurally before merging them.

Once the columns were standardized, I vertically concatenated the two datasets using pd.concat(). This effectively combined the ADHD and LD data into one unified data frame, called combined_sex_df, making it easier to conduct comparisons or visualizations across both conditions.

Finally, I used display() to output the combined data frame for further analysis or inspection. This preprocessing step established a clear framework for comparing the prevalence of ADHD and LD across different years and sexes.
"""

import pandas as pd

# Add Condition column
LD_sex_df["Condition"] = "LD"
ADHD_sex_df["Condition"] = "ADHD"

# Standardize column order
columns = ["Year", "Female Prevalence", "Female CI", "Male Prevalence", "Male CI", "Condition"]
LD_sex_df = LD_sex_df[columns]
ADHD_sex_df = ADHD_sex_df[columns]

# Combine longways
combined_sex_df = pd.concat([LD_sex_df, ADHD_sex_df], ignore_index=True)

# Display or use combined_sex_df
display(combined_sex_df)

"""At this analysis stage, I examined the data types of the `combined_sex_df` DataFrame using the `.dtypes` method to understand how the confidence interval (CI) columns were stored. I discovered that the "Female CI" and "Male CI" columns contained percentage signs, preventing these values from being treated numerically.

To clean the data, I first converted these columns to string format to safely perform string operations. I then used `.str.replace('%,''')` to remove the percentage signs from the confidence interval values. After cleaning, I converted the resulting strings to numeric using `pd.to_numeric()`, ensuring the columns could be treated as quantitative data. I set `errors='coerce'` so that any problematic entries would be converted to NaN instead of causing an error.

Finally, I re-checked the data types to confirm that the transformations successfully converted both CI columns from string to numeric format, preparing them for further statistical analysis or visualization.
"""

combined_sex_df.dtypes

combined_sex_df['Female CI'] = pd.to_numeric(combined_sex_df['Female CI'].astype(str).str.replace('%',''), errors='coerce')
combined_sex_df['Male CI'] = pd.to_numeric(combined_sex_df['Male CI'].astype(str).str.replace('%',''), errors='coerce')

combined_sex_df.dtypes

"""To investigate how well the sex-based prevalence and confidence interval data could predict whether a case was classified as ADHD or LD, I began by encoding the categorical target variable "Condition." Using LabelEncoder(), I transformed the string labels ("ADHD" and "LD") into numerical values and stored the results in a new column called "Condition_encoded." This step was necessary to ensure compatibility with sci-kit-learn's machine learning models.

Next, I defined the model's features (X) and the target variable (y). The features included the year, female and male prevalence, and their corresponding confidence intervals—essentially the columns that might help differentiate between ADHD and LD in the dataset. The target variable was the newly encoded condition label.

I then split the data into training and testing sets using train_test_split, reserving 30% of the data for testing. This approach ensures that the model is evaluated on unseen data, providing a more realistic estimate of its performance.

With the data split, I trained a decision tree classifier using DecisionTreeClassifier() with a maximum depth of 3 to prevent overfitting and maintain interpretability. After fitting the model on the training data, I used it to make predictions on the test set.

I printed three key metrics to evaluate the model's performance: accuracy, precision, and recall. Each was calculated using a weighted average to account for any class imbalance.

Finally, I visualized the model's performance and structure in two ways:

1. I generated a normalized confusion matrix using ConfusionMatrixDisplay.from_estimator() to assess how well the classifier distinguished between ADHD and LD.
2. I also plotted the structure of the trained decision tree using plot_tree(), which provided a visual summary of how the model made its decisions based on the input features.
"""

# Encode the target variable
le = LabelEncoder()
combined_sex_df['Condition_encoded'] = le.fit_transform(combined_sex_df['Condition'])

# Define features and target
features = ['Year', 'Female Prevalence', 'Female CI', 'Male Prevalence', 'Male CI']
X = combined_sex_df[features]
y = combined_sex_df['Condition_encoded']

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)

# Train decision tree
mod_dt = DecisionTreeClassifier(max_depth=3, random_state=1)
mod_dt.fit(X_train, y_train)
prediction = mod_dt.predict(X_test)

# Evaluation metrics
print(f"The accuracy of the Decision Tree is {metrics.accuracy_score(y_test, prediction):.3f}")
print(f"The Precision of the Decision Tree is {metrics.precision_score(y_test, prediction, average='weighted'):.3f}")
print(f"The Recall of the Decision Tree is {metrics.recall_score(y_test, prediction, average='weighted'):.3f}")

# Confusion Matrix
ConfusionMatrixDisplay.from_estimator(mod_dt, X_test, y_test,
                                      display_labels=le.classes_,
                                      cmap=plt.cm.Blues, normalize='all')
plt.show()

plt.figure(figsize=(12, 6))
plot_tree(mod_dt,
          feature_names=features,
          class_names=le.classes_,
          filled=True, rounded=True,
          fontsize=10)
plt.show()

"""**Figure 15** - Dicision Tree Classification Model: An examination of the role of gender in predicting disparities in diagnosis rates for ADHD and learning disabilities

**Analysis**

To examine how race and gender influence disparities in ADHD and learning disability diagnoses, I utilized two decision tree classification models. The first model, which focused on racial demographics, did not reveal any significant patterns; none of the racial categories contributed to the accuracy of the classification. This indicates that, within this dataset, race alone does not predict disparities in diagnoses, although it is possible that broader structural factors related to race were not accounted for.

In contrast, the second model used male prevalence as a proxy for gender and achieved perfect accuracy. This emphasizes an apparent diagnostic disparity based on gender: males were much more likely to be diagnosed with ADHD than with learning disabilities. This finding aligns with national trends and highlights a disparity in public health that is often discussed. I chose male prevalence specifically because it had the highest number of positive diagnoses, making it a strong standalone feature.

These findings underscore the effectiveness of decision tree models in identifying diagnostic disparities. They also indicate that gender, rather than race in this instance, plays a significant role in diagnosing ADHD and learning disabilities, pointing to important implications for equity in behavioral health assessments.

##Conclusion and Further Study
Ultimately, this project supports my hypothesis that race, gender, and particularly socioeconomic status significantly influence the rates at which learning disabilities and ADHD are diagnosed. Contrary to my initial assumption, children from low-income families consistently exhibit higher diagnosis rates for both conditions. This trend may be attributed to under-resourced educational environments and the compounding effects of poverty-related stress rather than overdiagnosis. Moreover, the disparity in diagnosis rates between males and females—where males are diagnosed more frequently—suggests that gender norms and social expectations may conceal learning challenges in girls.

While this study focused on public CDC data and utilized visualization and statistical tools to reveal trends, it also highlights the limitations of survey-based health data and the potential for systemic biases in diagnosis and reporting. This analysis only scratches the surface of the deeply rooted inequities in our educational and healthcare systems.

Looking beyond this dataset, public health institutions and educators must take proactive steps to examine their practices. For future research, I would explore school district-level data, including qualitative interviews with families, and investigate the impact of cultural stigma on diagnosis and treatment. This notebook is a foundation for a broader inquiry into how identity and environment intersect to shape access to care and educational support.
"""</pre>
</body>
</html>